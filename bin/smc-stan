#!/usr/bin/env python3

# imports
from datetime import timedelta
from getdist import MCSamples
import numpy as np
import arviz as az
import argparse
import pandas
import stan
import h5py
import time
import os

# simplifiedmc imports
from simplifiedmc.stan import load, save, criteria, getsteps, getflatsamples, timeseries, runlog
from simplifiedmc.shared import corner, syslog, CIs


# main
def main(args):
    # get the configutation from the global configuration file and/or CLI
    print("[*] Fetching arguments")
    model, data, output, config, names, labels, initial, markers, samples, warmup, chains, PSIS_LOO_CV, WAIC, AIC, BIC, DIC, overwrite, savechain, compress, hide_plots, init, ndim = load(args)

    # prepare the output folder
    print("\n[*] Setting up the output folder")
    if output[-1] == "/":
        output == output[:-1]
    if os.path.exists(output):
        if int(os.popen(f"find {output} -type f | wc -l").read()) and not overwrite:
            raise Exception(f"Output folder '{output}' is not empty. Overwrite existing files with the -ow, --overwrite flag or pick a different output folder.")
    os.system(f"mkdir -p {output}")
    os.system(f"mkdir {output}/plot")
    os.system(f"mkdir {output}/archive")
    os.system(f"mkdir {output}/archive/data")
    os.system(f"mkdir {output}/log")

    # get input data from the provided .csv file(s)
    print("\n[*] Importing input data")
    dic = {}
    aux = {0: None}
    i = 0
    for file in data:
        header = pandas.read_csv(file, comment="#", nrows=0).columns.tolist()
        columns = pandas.read_csv(file, comment="#")

        stack = False
        for j in range(0, i+1):
            if header == aux[j]:
                stack = True
                break

        if stack:
            dic[f"N{j}"] = dic[f"N{j}"] + len(columns[header[0]])
        else:
            i += 1
            aux[i] = header
            dic[f"N{i}"] = len(columns[header[0]])

        for var in header:
            if var not in dic.keys():
                dic[var] = np.array(columns[var])
            else:
                dic[var] = np.append(dic[var], np.array(columns[var]))

    # run the sampler
    print("\n[*] Running the sampler")
    with open(model, "r") as file:
        program = file.read()
    timestart = time.time()
    posterior = stan.build(program, data=dic)
    fit = posterior.sample(num_chains=chains, num_samples=samples, num_warmup=warmup, init=init, save_warmup=True)
    timeend = time.time()

    # compute execution time
    timeelapsed = timedelta(seconds = round(timeend - timestart))

    # convert fit to a numpy array of size [steps, chains, ndim], with all of the computed steps
    totalsteps = getsteps(fit, names, samples, warmup, chains, ndim)

    # flatten total steps (remove chain information) and remove warmup to a numpy array of size [steps, ndim]
    # then convert it to an MCSamples object for plotting in the corner plot
    flatsamples = getflatsamples(samples, warmup, chains, ndim, totalsteps)
    mcsamples = MCSamples(samples=flatsamples, names=names, labels=labels)

    # plotting routines
    print("\n[*] Plotting routines")
    timeseries(totalsteps, names, labels, markers, samples, warmup, chains, ndim, output=f"{output}/plot/time-series.png", noshow=hide_plots)
    corner(mcsamples, markers, output=f"{output}/plot/corner.png", noshow=hide_plots)

    # send relevant information to output folder
    print("\n[*] Saving to output folder")

    # save configuration arguments
    file = f"{output}/archive/config.yml"
    save(file, names, labels, initial, markers, samples, warmup, chains, PSIS_LOO_CV, WAIC, AIC, BIC, DIC, overwrite, savechain, compress, hide_plots)

    # save the model file
    os.system(f"cp {model} {output}/archive/model.stan")

    # save the data file(s)
    for file in data:
        os.system(f"cp {file} {output}/archive/data")

    # save the chain
    if savechain:
        with h5py.File(f"{output}/chain.h5", "w") as file:
            if compress:
                dataset = file.create_dataset("chain", data=totalsteps, compression="lzf", dtype="f")
            else:
                dataset = file.create_dataset("chain", data=totalsteps, dtype="f")

    # save arviz summary
    summary = az.summary(fit)
    summary.to_csv(path_or_buf=f"{output}/log/summary.csv")

    # save confidence intervals
    CIs(mcsamples, file=f"{output}/CIs.tex")

    # compute and save model selection criteria
    criteria(fit, PSIS_LOO_CV, WAIC, AIC, BIC, DIC, file=f"{output}/criteria.log", plotkhat=f"{output}/plot/khat.png", noshow=hide_plots)

    # save run information
    runlog(timeelapsed, file=f"{output}/log/run.log")

    # save machine information
    syslog(file=f"{output}/log/sys.log")

    return


# run if called
if __name__ == "__main__":
    # create parser
    parser = argparse.ArgumentParser(description = "A CLI that automates parameter constraining using the Stan programming language.", add_help=False, epilog="Project homepage:\nhttps://github.com/jpmvferreira/simplifiedmc")

    # create argparser subgroups
    parser._action_groups.pop()
    required = parser.add_argument_group("Required arguments")
    config = parser.add_argument_group("Global configuration file")
    sampler = parser.add_argument_group("Sampler configuration")
    model = parser.add_argument_group("Model selection criteria")
    output = parser.add_argument_group("Output configuration")
    run = parser.add_argument_group("Run configuration")
    help = parser.add_argument_group("Help dialog")

    # required arguments
    required.add_argument("-m", "--model", type=str, help="Stan model input file.", required=True)
    required.add_argument("-d", "--data", nargs="*", help="Data from .csv file(s).", required=True)
    required.add_argument("-o", "--output", type=str, help="Output folder.", required=True)

    # global configuration file
    config.add_argument("-cfg", "--config", type=str, help="YAML file to configure the program/sampler behaviour. The arguments available in the next sections, if provided, will overwrite the configuration provided by this file.")

    # sampler configuration
    sampler.add_argument("-n", "--names", type=str, help="String with a Python like list with the names for each parameter, e.g.: \"['a', 'b']\". Must match the names defined in the .stan model file.")
    sampler.add_argument("-l", "--labels", type=str, help="A string with a Python like list with the labels for each parameter, e.g.: \"['\\alpha', '\\beta']\". Defaults to the name of each parameter.")
    sampler.add_argument("-i", "--initial", type=str, help="String with a Python style dictionary with the initial condition for each parameter, e.g.: \"['a': 'gauss(0, 1)', 'b': 'uniform(0, 1)']\".")
    sampler.add_argument("--markers", type=str, help="String with a Python style dictionary with the line markers to show rendered in the plots, e.g.: \"{'a': 0.5, 'b': 1.2}\". Defaults to none.")
    sampler.add_argument("-s", "--samples", type=int, help="Number of steps to sample the posterior distribution, after the warmup.")
    sampler.add_argument("-w", "--warmup", type=int, help="Number of steps to warmup each chain.")
    sampler.add_argument("-c", "--chains", type=int, help="Number of chains to run. Will run in parallel or sequentially based on the number of available threads, which can be limited with 'threads' configuration.")

    # model selection criteria
    model.add_argument("--PSIS-LOO-CV", action="store_true", help="Compute the Pareto-smoothed importance sampling leave-one-out cross-validation.")
    model.add_argument("--WAIC", action="store_true", help="Compute the Watanabeâ€“Akaike information criterion.")
    model.add_argument("--AIC", action="store_true", help="Compute the Akaike information criterion. (NO WORKERINO)")
    model.add_argument("--BIC", action="store_true", help="Compute the Bayesian information criterion. (NO WORKERINO)")
    model.add_argument("--DIC", action="store_true", help="Compute the deviance information criterion. (NO WORKERINO)")

    # output configuration
    output.add_argument("-ow", "--overwrite", action="store_true", help="Overwrite existing files, if they exist.")
    output.add_argument("-sc", "--save-chain", action="store_true", help="Saves the chain to disk, in HDF5.")
    output.add_argument("-co", "--compress", action="store_true", help="Compress the chain, using LZF.")
    output.add_argument("-hp", "--hide-plots", action="store_true", help="Don't show plots on screen.")

    # run configuration
    run.add_argument("-t", "--threads", type=int, help="Set a maximum number of threads. Defaults to either the number of chains, or the available hardware threads, depending on which is lowest. (NO WORKERINO)")

    # add help to its own subsection
    help.add_argument("-h", "--help", action="help", default=argparse.SUPPRESS, help="Show this help message and exit.")

    # get arguments
    args = parser.parse_args()

    # call main with the provided arguments
    main(args)
